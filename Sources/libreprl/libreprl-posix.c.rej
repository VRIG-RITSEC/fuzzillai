diff a/Sources/libreprl/libreprl-posix.c b/Sources/libreprl/libreprl-posix.c	(rejected hunks)
@@ -30,12 +30,17 @@
 #include <stdlib.h>
 #include <string.h>
 #include <sys/mman.h>
+#include <sys/resource.h>
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <time.h>
 #include <unistd.h>
 
+// The REPRL protocol version. Must be identical between server and client.
+// Bump this up whenever there are non-backwards-compatible changes to the protocol
+#define REPRL_PROTOCOL_VERSION 2
+
 // Well-known file descriptor numbers for reprl <-> child communication, child process side
 #define REPRL_CHILD_CTRL_IN 100
 #define REPRL_CHILD_CTRL_OUT 101
@@ -141,7 +146,7 @@ static struct data_channel* reprl_create_data_channel(struct reprl_context* ctx)
         reprl_error(ctx, "Failed to mmap data channel file: %s", strerror(errno));
         return NULL;
     }
-    
+
     struct data_channel* channel = malloc(sizeof(struct data_channel));
     channel->fd = fd;
     channel->mapping = mapping;
@@ -214,6 +219,19 @@ static int reprl_spawn_child(struct reprl_context* ctx)
             _exit(-1);
         }
 
+	#ifdef __linux__
+        // Set RLIMIT_CORE to 0, such that we don't produce core dumps. The
+        // added benefit of doing this here, in the child process, is that we
+        // can still get core dumps when Fuzzilli crashes.
+        struct rlimit core_limit;
+        core_limit.rlim_cur = 0;
+        core_limit.rlim_max = 0;
+        if (setrlimit(RLIMIT_CORE, &core_limit) < 0) {
+            fprintf(stderr, "setrlimit failed in the child: %s\n", strerror(errno));
+            _exit(-1);
+        };
+	#endif
+
         // Unblock any blocked signals. It seems that libdispatch sometimes blocks delivery of certain signals.
         sigset_t newset;
         sigemptyset(&newset);
@@ -259,21 +277,42 @@ static int reprl_spawn_child(struct reprl_context* ctx)
     }
     ctx->pid = pid;
 
-    char helo[5] = { 0 };
-    if (read(ctx->ctrl_in, helo, 4) != 4) {
+    char handshake[5] = { 0 };
+    if (read(ctx->ctrl_in, handshake, 4) != 4) {
         reprl_terminate_child(ctx);
-        return reprl_error(ctx, "Did not receive HELO message from child: %s", strerror(errno));
+        return reprl_error(ctx, "Did not receive handshake message from child: %s", strerror(errno));
     }
-    
-    if (strncmp(helo, "HELO", 4) != 0) {
+
+    if (strncmp(handshake, "HELO", 4) == 0) {
+        // Client is using protocol version 1.
         reprl_terminate_child(ctx);
-        return reprl_error(ctx, "Received invalid HELO message from child: %s", helo);
+        return reprl_error(ctx, "The client uses an old version of the REPRL protocol, please update it to the latest version");
     }
-    
-    if (write(ctx->ctrl_out, helo, 4) != 4) {
+
+    if (strncmp(handshake, "XDXD", 4) != 0) {
+        reprl_terminate_child(ctx);
+        return reprl_error(ctx, "Received invalid handshake message from child: %s", handshake);
+    }
+
+    // The server side just sends back the handshake message, but not the protocol version.
+    if (write(ctx->ctrl_out, handshake, 4) != 4) {
+        reprl_terminate_child(ctx);
+        return reprl_error(ctx, "Failed to send handshake reply message to child: %s", strerror(errno));
+    }
+
+    #ifdef __linux__
+    struct rlimit core_limit = {};
+    if (prlimit(pid, RLIMIT_CORE, NULL, &core_limit) < 0) {
         reprl_terminate_child(ctx);
-        return reprl_error(ctx, "Failed to send HELO reply message to child: %s", strerror(errno));
+        return reprl_error(ctx, "prlimit failed: %s\n", strerror(errno));
     }
+    if (core_limit.rlim_cur != 0 || core_limit.rlim_max != 0) {
+        reprl_terminate_child(ctx);
+        return reprl_error(ctx, "Detected non-zero RLIMIT_CORE. Check that the child does not set RLIMIT_CORE manually.\n");
+    }
+    #endif
+
+
 
     return 0;
 }
@@ -326,20 +365,20 @@ int reprl_initialize_context(struct reprl_context* ctx, const char** argv, const
 void reprl_destroy_context(struct reprl_context* ctx)
 {
     reprl_terminate_child(ctx);
-    
+
     free_string_array(ctx->argv);
     free_string_array(ctx->envp);
-    
+
     reprl_destroy_data_channel(ctx->data_in);
     reprl_destroy_data_channel(ctx->data_out);
     reprl_destroy_data_channel(ctx->child_stdout);
     reprl_destroy_data_channel(ctx->child_stderr);
-    
+
     free(ctx->last_error);
     free(ctx);
 }
 
-int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script_length, uint64_t timeout, uint64_t* execution_time, int fresh_instance)
+int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script_length, uint64_t timeout, uint64_t* execution_time, int fresh_instance, uint32_t source_pos_dump_seed, uint8_t* jit_state)
 {
     if (!ctx->initialized) {
         return reprl_error(ctx, "REPRL context is not initialized");
@@ -363,11 +402,14 @@ int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script
     lseek(ctx->data_in->fd, 0, SEEK_SET);
     if (ctx->child_stdout) {
         lseek(ctx->child_stdout->fd, 0, SEEK_SET);
+
+        memset(ctx->child_stdout->mapping, 0, REPRL_MAX_DATA_SIZE);
     }
+
     if (ctx->child_stderr) {
         lseek(ctx->child_stderr->fd, 0, SEEK_SET);
     }
-    
+
     // Spawn a new instance if necessary.
     if (!ctx->pid) {
         int r = reprl_spawn_child(ctx);
@@ -379,6 +421,7 @@ int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script
 
     // Tell child to execute the script.
     if (write(ctx->ctrl_out, "exec", 4) != 4 ||
+        write(ctx->ctrl_out, &source_pos_dump_seed, sizeof(source_pos_dump_seed)) != sizeof(source_pos_dump_seed) ||
         write(ctx->ctrl_out, &script_length, 8) != 8) {
         // These can fail if the child unexpectedly terminated between executions.
         // Check for that here to be able to provide a better error message.
@@ -408,13 +451,26 @@ int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script
         // We expect all signal handlers to be installed with SA_RESTART, so receiving EINTR here is unexpected and thus also an error.
         return reprl_error(ctx, "Failed to poll: %s", strerror(errno));
     }
-    
+
     // Poll succeeded, so there must be something to read now (either the status or EOF).
+    #pragma pack(1)
+    struct {
+        int status;
+        uint8_t jit_state;
+    } s;
+    // we only want to read 5 bytes and not care about padding
+    // just to be sure for the future
+    const size_t ssize = 5;
+
+
+    ssize_t rv = read(ctx->ctrl_in, &s, ssize);
     int status;
-    ssize_t rv = read(ctx->ctrl_in, &status, 4);
+
+    // printf("---STDOUT---\n%s\n", reprl_fetch_stdout(ctx));
+    // printf("---STDERR---\n%s\n", reprl_fetch_stderr(ctx));
     if (rv < 0) {
         return reprl_error(ctx, "Failed to read from control pipe: %s", strerror(errno));
-    } else if (rv != 4) {
+    } else if (rv != ssize) {
         // Most likely, the child process crashed and closed the write end of the control pipe.
         // Unfortunately, there probably is nothing that guarantees that waitpid() will immediately succeed now,
         // and we also don't want to block here. So just retry waitpid() a few times...
@@ -423,7 +479,6 @@ int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script
             success = waitpid(ctx->pid, &status, WNOHANG) == ctx->pid;
             if (!success) usleep(10);
         } while (!success && current_usecs() - start_time < timeout);
-        
         if (!success) {
             // Wait failed, so something weird must have happened. Maybe somehow the control pipe was closed without the child exiting?
             // Probably the best we can do is kill the child and return an error.
@@ -443,7 +498,11 @@ int reprl_execute(struct reprl_context* ctx, const char* script, uint64_t script
             return reprl_error(ctx, "Waitpid returned unexpected child state %i", status);
         }
     }
-    
+    else {
+        status = s.status;
+        *jit_state = s.jit_state;
+    }
+
     // The status must be a positive number, see the status encoding format below.
     // We also don't allow the child process to indicate a timeout. If we wanted,
     // we could treat it as an error if the upper bits are set.
